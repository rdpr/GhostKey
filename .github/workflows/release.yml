name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Read version
      id: version
      run: |
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Building version $VERSION"
    
    - name: Check if tag exists
      id: check_tag
      run: |
        if git rev-parse "v${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è  Tag v${{ steps.version.outputs.version }} already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Tag v${{ steps.version.outputs.version }} is new"
        fi
    
    - name: Skip if tag exists
      if: steps.check_tag.outputs.exists == 'true'
      run: |
        echo "::warning::Version v${{ steps.version.outputs.version }} already released. Update VERSION file to create a new release."
        exit 0
    
    - name: Setup Xcode
      if: steps.check_tag.outputs.exists == 'false'
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install Sparkle CLI tools
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üì• Installing Sparkle CLI tools..."
        cd /tmp
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz
        sudo cp -f bin/sign_update /usr/local/bin/
        sudo cp -f bin/generate_appcast /usr/local/bin/
        sudo chmod +x /usr/local/bin/sign_update
        sudo chmod +x /usr/local/bin/generate_appcast
        echo "‚úÖ Sparkle CLI tools installed"
        which sign_update
        which generate_appcast
        sign_update -v || echo "sign_update ready"
    
    - name: Load and verify Sparkle keys
      if: steps.check_tag.outputs.exists == 'false'
      id: sparkle_keys
      run: |
        PRIVATE_KEY="${{ secrets.SPARKLE_PRIVATE_KEY }}"
        PUBLIC_KEY_IN_PLIST=$(grep -A 1 "SUPublicEDKey" GhostKey/Info.plist | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/' | tr -d '[:space:]')
        
        echo "üîç Public key in Info.plist: $PUBLIC_KEY_IN_PLIST"
        echo "üîç Private key length: ${#PRIVATE_KEY}"
        
        # Create a test file to verify the key pair works
        echo "test content" > /tmp/test.txt
        zip /tmp/test.zip /tmp/test.txt
        
        # Write private key to file
        echo "$PRIVATE_KEY" > /tmp/test_key.pem
        chmod 600 /tmp/test_key.pem
        
        # Try to sign the test file
        echo "üîê Testing key pair with test file..."
        TEST_SIG=$(sign_update /tmp/test.zip --ed-key-file /tmp/test_key.pem 2>&1)
        echo "üîç Test signature output: $TEST_SIG"
        
        if echo "$TEST_SIG" | grep -q "sparkle:edSignature"; then
          echo "‚úÖ Private key can sign files"
        else
          echo "‚ùå Private key failed to sign test file"
          echo "Output: $TEST_SIG"
        fi
        
        # Clean up
        rm -f /tmp/test.txt /tmp/test.zip /tmp/test_key.pem
        
        echo "private_key=$PRIVATE_KEY" >> $GITHUB_OUTPUT
    
    - name: Build app
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üî® Building GhostKey..."
        
        VERSION="${{ steps.version.outputs.version }}"
        
        # Set version in Info.plist before building
        /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" GhostKey/Info.plist 2>/dev/null || \
        /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $VERSION" GhostKey/Info.plist
        
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" GhostKey/Info.plist 2>/dev/null || \
        /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $VERSION" GhostKey/Info.plist
        
        echo "‚úÖ Version set to $VERSION in Info.plist"
        
        xcodebuild clean build \
          -project GhostKey.xcodeproj \
          -scheme GhostKey \
          -configuration Release \
          -derivedDataPath ./build \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          CODE_SIGNING_ALLOWED=NO \
          MARKETING_VERSION="$VERSION" \
          CURRENT_PROJECT_VERSION="$VERSION"
        
        echo "‚úÖ Build complete"
        
        # Verify version in built app
        echo "üîç Verifying version in built app..."
        BUILT_APP=$(find ./build -name "GhostKey.app" -type d | head -n 1)
        if [ -n "$BUILT_APP" ]; then
          BUILT_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$BUILT_APP/Contents/Info.plist" 2>/dev/null || echo "not found")
          echo "Built app version: $BUILT_VERSION"
          if [ "$BUILT_VERSION" != "$VERSION" ]; then
            echo "‚ö†Ô∏è  Version mismatch! Expected $VERSION, got $BUILT_VERSION"
          else
            echo "‚úÖ Version verified in built app"
          fi
        fi
    
    - name: Prepare app bundle
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üì¶ Preparing app bundle..."
        
        # Find the built app
        APP_PATH=$(find ./build -name "GhostKey.app" -type d | head -n 1)
        
        if [ -z "$APP_PATH" ]; then
          echo "‚ùå GhostKey.app not found"
          exit 1
        fi
        
        echo "Found app at: $APP_PATH"
        
        # Create distribution directory
        mkdir -p ./dist
        
        # Copy app to distribution directory
        cp -R "$APP_PATH" ./dist/GhostKey.app
        
        # Ensure executable has correct permissions
        echo "üîß Setting executable permissions..."
        chmod +x ./dist/GhostKey.app/Contents/MacOS/GhostKey
        
        # Verify bundle structure
        echo "üìã Verifying bundle structure..."
        if [ ! -f "./dist/GhostKey.app/Contents/MacOS/GhostKey" ]; then
          echo "‚ùå Executable not found!"
          exit 1
        fi
        if [ ! -f "./dist/GhostKey.app/Contents/Info.plist" ]; then
          echo "‚ùå Info.plist not found!"
          exit 1
        fi
        
        echo "‚úÖ App bundle prepared and verified"
    
    - name: Create ZIP archive
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üì¶ Creating ZIP archive..."
        cd ./dist
        
        # Use ditto instead of zip for better compatibility with macOS
        cd ..
        ditto -c -k --sequesterRsrc --keepParent ./dist/GhostKey.app "GhostKey-${{ steps.version.outputs.version }}.zip"
        
        # Verify ZIP was created
        if [ ! -f "GhostKey-${{ steps.version.outputs.version }}.zip" ]; then
          echo "‚ùå ZIP creation failed"
          exit 1
        fi
        
        # Calculate and store SHA256 before signing
        SHA_BEFORE=$(shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.zip" | awk '{print $1}')
        echo "üîç ZIP SHA256 (before signing): $SHA_BEFORE"
        echo "$SHA_BEFORE" > zip_sha_before.txt
        
        echo "‚úÖ ZIP created: GhostKey-${{ steps.version.outputs.version }}.zip"
    
    - name: Install create-dmg
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üì• Installing create-dmg..."
        brew install create-dmg
    
    - name: Create DMG
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üì¶ Creating DMG..."
        
        # Create DMG with nice window and background
        create-dmg \
          --volname "GhostKey" \
          --volicon "./Media.xcassets/AppIcon.appiconset/GhostKey-512.png" \
          --window-pos 200 120 \
          --window-size 600 400 \
          --icon-size 100 \
          --icon "GhostKey.app" 175 190 \
          --hide-extension "GhostKey.app" \
          --app-drop-link 425 190 \
          --no-internet-enable \
          "GhostKey-${{ steps.version.outputs.version }}.dmg" \
          "./dist/GhostKey.app" || true
        
        # Fallback: If create-dmg fails, create a simple DMG
        if [ ! -f "GhostKey-${{ steps.version.outputs.version }}.dmg" ]; then
          echo "‚ö†Ô∏è  create-dmg failed, creating simple DMG..."
          hdiutil create -volname "GhostKey" \
            -srcfolder "./dist/GhostKey.app" \
            -ov -format UDZO \
            "GhostKey-${{ steps.version.outputs.version }}.dmg"
        fi
        
        echo "‚úÖ DMG created: GhostKey-${{ steps.version.outputs.version }}.dmg"
    
    - name: Generate appcast with Sparkle
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üìù Generating appcast with Sparkle..."
        
        PRIVATE_KEY="${{ steps.sparkle_keys.outputs.private_key }}"
        KEY_FILE="/tmp/sparkle_private_key.pem"
        
        # Write private key to temporary file
        echo "$PRIVATE_KEY" > "$KEY_FILE"
        chmod 600 "$KEY_FILE"
        
        # Create archives directory for generate_appcast
        mkdir -p archives
        cp "GhostKey-${{ steps.version.outputs.version }}.zip" archives/
        
        # Generate appcast using Sparkle's official tool
        echo "üîê Running generate_appcast..."
        generate_appcast \
          --ed-key-file "$KEY_FILE" \
          --download-url-prefix "https://github.com/rdpr/GhostKey/releases/download/v${{ steps.version.outputs.version }}/" \
          --link "https://github.com/rdpr/GhostKey" \
          --release-notes-url-prefix "https://github.com/rdpr/GhostKey/releases/tag/v" \
          archives
        
        # Move generated appcast to root
        if [ -f "archives/appcast.xml" ]; then
          # If we have an existing appcast, merge the new entry
          if [ -f "appcast.xml" ]; then
            echo "üìù Merging with existing appcast..."
            # Extract the new item from generated appcast
            NEW_ITEM=$(sed -n '/<item>/,/<\/item>/p' archives/appcast.xml)
            # Insert at the beginning of our existing appcast
            awk -v item="$NEW_ITEM" '/<channel>/ {print; print item; next} 1' appcast.xml > appcast_new.xml
            mv appcast_new.xml appcast.xml
          else
            # No existing appcast, use the generated one
            cp archives/appcast.xml appcast.xml
          fi
          echo "‚úÖ Appcast generated successfully"
        else
          echo "‚ùå generate_appcast failed"
          exit 1
        fi
        
        # Clean up
        rm -f "$KEY_FILE"
        rm -rf archives
        
        # Show generated appcast entry for debugging
        echo "üìã Generated appcast entry:"
        grep -A 20 "<item>" appcast.xml | head -25
    
    - name: Commit appcast changes
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üíæ Committing appcast changes..."
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # Restore Info.plist to avoid committing version changes
        git checkout GhostKey/Info.plist
        
        git add appcast.xml
        
        if git diff --staged --quiet; then
          echo "‚ö†Ô∏è  No changes to commit"
        else
          git commit -m "chore: update appcast for v${{ steps.version.outputs.version }}"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
          echo "‚úÖ Appcast committed and pushed"
        fi
    
    - name: Generate checksums
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üîê Generating checksums..."
        shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.zip" > "GhostKey-${{ steps.version.outputs.version }}.zip.sha256"
        shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.dmg" > "GhostKey-${{ steps.version.outputs.version }}.dmg.sha256"
        
        echo "üìã Checksums:"
        cat "GhostKey-${{ steps.version.outputs.version }}.zip.sha256"
        cat "GhostKey-${{ steps.version.outputs.version }}.dmg.sha256"
    
    - name: Create release notes
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üìù Generating release notes..."
        
        cat > release_notes.md << 'EOF'
        ## GhostKey v${{ steps.version.outputs.version }}
        
        ### üì¶ Installation
        
        Choose one of the following:
        
        1. **DMG (Recommended)**: Download `GhostKey-${{ steps.version.outputs.version }}.dmg`, open it, and drag GhostKey to your Applications folder
        2. **ZIP**: Download `GhostKey-${{ steps.version.outputs.version }}.zip`, extract it, and move GhostKey.app to your Applications folder
        
        ### üîí Important: Opening the App
        
        This build is **not code-signed or notarized**. macOS Gatekeeper will block it by default.
        
        **Required step to open the app**:
        
        Open Terminal and run this command:
        ```bash
        xattr -d com.apple.quarantine /Applications/GhostKey.app
        ```
        
        Then double-click GhostKey.app to open it normally.
        
        > **Note**: This removes the quarantine flag that macOS adds to downloaded apps. You only need to do this once.
        
        ### ‚ö†Ô∏è Known Limitation: Notifications
        
        **System notifications will NOT work** in this unsigned build. macOS requires apps to be code-signed to register for notifications.
        
        **If you need notifications**, you must build from source:
        1. Clone the repository
        2. Open `GhostKey.xcodeproj` in Xcode
        3. Build and run (‚åòR)
        
        Local builds are automatically signed by Xcode and have full notification support.
        
        See [DEVELOPMENT.md](https://github.com/rdpr/ghostkey/blob/main/DEVELOPMENT.md#notification-issues-unsigned-apps) for details.
        
        ### ‚úÖ Checksums
        
        Verify your download:
        
        ```
        $(cat GhostKey-${{ steps.version.outputs.version }}.zip.sha256)
        $(cat GhostKey-${{ steps.version.outputs.version }}.dmg.sha256)
        ```
        
        ### üìã What's New
        
        See [CHANGELOG.md](https://github.com/rdpr/ghostkey/blob/main/CHANGELOG.md) for detailed changes.
        
        ---
        
        **Requirements**: macOS 12.0 (Monterey) or later
        
        **Permissions**: Accessibility access required for typing codes (you'll be prompted on first use)
        EOF
        
        echo "‚úÖ Release notes generated"
    
    - name: Create Git tag
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "üè∑Ô∏è  Creating tag v${{ steps.version.outputs.version }}..."
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release v${{ steps.version.outputs.version }}"
        
        # Push tag using HTTPS with token
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "v${{ steps.version.outputs.version }}"
        
        echo "‚úÖ Tag created and pushed"
    
    - name: Create GitHub Release
      if: steps.check_tag.outputs.exists == 'false'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.version }}
        name: v${{ steps.version.outputs.version }}
        body_path: release_notes.md
        draft: false
        prerelease: false
        files: |
          GhostKey-${{ steps.version.outputs.version }}.zip
          GhostKey-${{ steps.version.outputs.version }}.zip.sha256
          GhostKey-${{ steps.version.outputs.version }}.dmg
          GhostKey-${{ steps.version.outputs.version }}.dmg.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Release summary
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "## üéâ Release Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Version**: v${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üì¶ Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- \`GhostKey-${{ steps.version.outputs.version }}.dmg\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`GhostKey-${{ steps.version.outputs.version }}.zip\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîó Links" >> $GITHUB_STEP_SUMMARY
        echo "- [Release Page](https://github.com/rdpr/ghostkey/releases/tag/v${{ steps.version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
        echo "- [All Releases](https://github.com/rdpr/ghostkey/releases)" >> $GITHUB_STEP_SUMMARY

