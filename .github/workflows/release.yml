name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Read version
      id: version
      run: |
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Building version $VERSION"
    
    - name: Check if tag exists
      id: check_tag
      run: |
        if git rev-parse "v${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "âš ï¸  Tag v${{ steps.version.outputs.version }} already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "âœ… Tag v${{ steps.version.outputs.version }} is new"
        fi
    
    - name: Skip if tag exists
      if: steps.check_tag.outputs.exists == 'true'
      run: |
        echo "::warning::Version v${{ steps.version.outputs.version }} already released. Update VERSION file to create a new release."
        exit 0
    
    - name: Setup Xcode
      if: steps.check_tag.outputs.exists == 'false'
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install Sparkle CLI tools
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“¥ Installing Sparkle CLI tools..."
        cd /tmp
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz
        sudo cp -f bin/sign_update /usr/local/bin/
        sudo cp -f bin/generate_appcast /usr/local/bin/
        sudo chmod +x /usr/local/bin/sign_update
        sudo chmod +x /usr/local/bin/generate_appcast
        echo "âœ… Sparkle CLI tools installed"
        which sign_update
        which generate_appcast
        sign_update -v || echo "sign_update ready"
    
    - name: Load and verify Sparkle keys
      if: steps.check_tag.outputs.exists == 'false'
      id: sparkle_keys
      run: |
        PRIVATE_KEY="${{ secrets.SPARKLE_PRIVATE_KEY }}"
        PUBLIC_KEY_IN_PLIST=$(grep -A 1 "SUPublicEDKey" GhostKey/Info.plist | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/' | tr -d '[:space:]')
        
        echo "ðŸ” Public key in Info.plist: $PUBLIC_KEY_IN_PLIST"
        echo "ðŸ” Private key length: ${#PRIVATE_KEY}"
        
        # Create a test file to verify the key pair works
        echo "test content" > /tmp/test.txt
        zip /tmp/test.zip /tmp/test.txt
        
        # Write private key to file
        echo "$PRIVATE_KEY" > /tmp/test_key.pem
        chmod 600 /tmp/test_key.pem
        
        # Try to sign the test file
        echo "ðŸ” Testing key pair with test file..."
        TEST_SIG=$(sign_update /tmp/test.zip --ed-key-file /tmp/test_key.pem 2>&1)
        echo "ðŸ” Test signature output: $TEST_SIG"
        
        if echo "$TEST_SIG" | grep -q "sparkle:edSignature"; then
          echo "âœ… Private key can sign files"
        else
          echo "âŒ Private key failed to sign test file"
          echo "Output: $TEST_SIG"
        fi
        
        # Clean up
        rm -f /tmp/test.txt /tmp/test.zip /tmp/test_key.pem
        
        echo "private_key=$PRIVATE_KEY" >> $GITHUB_OUTPUT
    
    - name: Build app
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ï¿½ï¿½ Building GhostKey..."
        
        VERSION="${{ steps.version.outputs.version }}"
        
        # Set version in Info.plist before building
        /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" GhostKey/Info.plist 2>/dev/null || \
        /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $VERSION" GhostKey/Info.plist
        
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" GhostKey/Info.plist 2>/dev/null || \
        /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $VERSION" GhostKey/Info.plist
        
        echo "âœ… Version set to $VERSION in Info.plist"
        
        xcodebuild clean build \
          -project GhostKey.xcodeproj \
          -scheme GhostKey \
          -configuration Release \
          -derivedDataPath ./build \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          CODE_SIGNING_ALLOWED=NO \
          MARKETING_VERSION="$VERSION" \
          CURRENT_PROJECT_VERSION="$VERSION"
        
        echo "âœ… Build complete"
        
        # Verify version in built app
        echo "ðŸ” Verifying version in built app..."
        BUILT_APP=$(find ./build -name "GhostKey.app" -type d | head -n 1)
        if [ -n "$BUILT_APP" ]; then
          BUILT_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$BUILT_APP/Contents/Info.plist" 2>/dev/null || echo "not found")
          echo "Built app version: $BUILT_VERSION"
          if [ "$BUILT_VERSION" != "$VERSION" ]; then
            echo "âš ï¸  Version mismatch! Expected $VERSION, got $BUILT_VERSION"
          else
            echo "âœ… Version verified in built app"
          fi
        fi
    
    - name: Prepare app bundle
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“¦ Preparing app bundle..."
        
        # Find the built app
        APP_PATH=$(find ./build -name "GhostKey.app" -type d | head -n 1)
        
        if [ -z "$APP_PATH" ]; then
          echo "âŒ GhostKey.app not found"
          exit 1
        fi
        
        echo "Found app at: $APP_PATH"
        
        # Create distribution directory
        mkdir -p ./dist
        
        # Copy app to distribution directory
        cp -R "$APP_PATH" ./dist/GhostKey.app
        
        # Ensure executable has correct permissions
        echo "ðŸ”§ Setting executable permissions..."
        chmod +x ./dist/GhostKey.app/Contents/MacOS/GhostKey
        
        # Verify bundle structure
        echo "ðŸ“‹ Verifying bundle structure..."
        if [ ! -f "./dist/GhostKey.app/Contents/MacOS/GhostKey" ]; then
          echo "âŒ Executable not found!"
          exit 1
        fi
        if [ ! -f "./dist/GhostKey.app/Contents/Info.plist" ]; then
          echo "âŒ Info.plist not found!"
          exit 1
        fi
        
        echo "âœ… App bundle prepared and verified"
    
    - name: Create ZIP archive
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“¦ Creating ZIP archive..."
        cd ./dist
        
        # Use ditto instead of zip for better compatibility with macOS
        cd ..
        ditto -c -k --sequesterRsrc --keepParent ./dist/GhostKey.app "GhostKey-${{ steps.version.outputs.version }}.zip"
        
        # Verify ZIP was created
        if [ ! -f "GhostKey-${{ steps.version.outputs.version }}.zip" ]; then
          echo "âŒ ZIP creation failed"
          exit 1
        fi
        
        # Calculate and store SHA256 before signing
        SHA_BEFORE=$(shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.zip" | awk '{print $1}')
        echo "ðŸ” ZIP SHA256 (before signing): $SHA_BEFORE"
        echo "$SHA_BEFORE" > zip_sha_before.txt
        
        echo "âœ… ZIP created: GhostKey-${{ steps.version.outputs.version }}.zip"
    
    - name: Install create-dmg
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“¥ Installing create-dmg..."
        brew install create-dmg
    
    - name: Create DMG
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“¦ Creating DMG..."
        
        # Create DMG with nice window and background
        create-dmg \
          --volname "GhostKey" \
          --volicon "./Media.xcassets/AppIcon.appiconset/GhostKey-512.png" \
          --window-pos 200 120 \
          --window-size 600 400 \
          --icon-size 100 \
          --icon "GhostKey.app" 175 190 \
          --hide-extension "GhostKey.app" \
          --app-drop-link 425 190 \
          --no-internet-enable \
          "GhostKey-${{ steps.version.outputs.version }}.dmg" \
          "./dist/GhostKey.app" || true
        
        # Fallback: If create-dmg fails, create a simple DMG
        if [ ! -f "GhostKey-${{ steps.version.outputs.version }}.dmg" ]; then
          echo "âš ï¸  create-dmg failed, creating simple DMG..."
          hdiutil create -volname "GhostKey" \
            -srcfolder "./dist/GhostKey.app" \
            -ov -format UDZO \
            "GhostKey-${{ steps.version.outputs.version }}.dmg"
        fi
        
        echo "âœ… DMG created: GhostKey-${{ steps.version.outputs.version }}.dmg"
    
    - name: Sign ZIP and create appcast entry
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ” Signing ZIP and creating appcast..."
        
        PRIVATE_KEY="${{ steps.sparkle_keys.outputs.private_key }}"
        ZIP_FILE="GhostKey-${{ steps.version.outputs.version }}.zip"
        KEY_FILE="/tmp/sparkle_private_key.pem"
        VERSION="${{ steps.version.outputs.version }}"
        
        # Write private key to temporary file
        echo -n "$PRIVATE_KEY" > "$KEY_FILE"
        chmod 600 "$KEY_FILE"
        
        # Sign the ZIP
        echo "ðŸ” Signing $ZIP_FILE..."
        sign_update "$ZIP_FILE" --ed-key-file "$KEY_FILE" > /tmp/signature_output.txt
        
        # Extract signature (format: sparkle:edSignature="..." length="...")
        SIGNATURE=$(grep -o 'sparkle:edSignature="[^"]*"' /tmp/signature_output.txt | sed 's/sparkle:edSignature="//;s/"//')
        ZIP_SIZE=$(stat -f%z "$ZIP_FILE" 2>/dev/null || stat -c%s "$ZIP_FILE")
        
        echo "âœ… Signature: ${SIGNATURE:0:50}..."
        echo "âœ… Size: $ZIP_SIZE bytes"
        
        # Get app version from Info.plist in the ZIP
        unzip -q "$ZIP_FILE" "GhostKey.app/Contents/Info.plist" -d /tmp/extract
        APP_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" /tmp/extract/GhostKey.app/Contents/Info.plist)
        MIN_OS=$(/usr/libexec/PlistBuddy -c "Print :LSMinimumSystemVersion" /tmp/extract/GhostKey.app/Contents/Info.plist 2>/dev/null || echo "14.0")
        rm -rf /tmp/extract
        
        echo "âœ… App version: $APP_VERSION"
        echo "âœ… Min OS: $MIN_OS"
        
        # Create appcast entry
        PUBDATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
        DOWNLOAD_URL="https://github.com/rdpr/GhostKey/releases/download/v${VERSION}/GhostKey-${VERSION}.zip"
        
        # Create new item XML using echo
        echo "            <item>" > new_item.xml
        echo "                <title>Version ${APP_VERSION}</title>" >> new_item.xml
        echo "                <link>https://github.com/rdpr/GhostKey/releases/tag/v${VERSION}</link>" >> new_item.xml
        echo "                <sparkle:version>${APP_VERSION}</sparkle:version>" >> new_item.xml
        echo "                <sparkle:shortVersionString>${APP_VERSION}</sparkle:shortVersionString>" >> new_item.xml
        echo "                <description><![CDATA[" >> new_item.xml
        echo "                    <h2>GhostKey ${APP_VERSION}</h2>" >> new_item.xml
        echo "                    <p>See <a href=\"https://github.com/rdpr/GhostKey/releases/tag/v${VERSION}\">release notes</a> for details.</p>" >> new_item.xml
        echo "                ]]></description>" >> new_item.xml
        echo "                <pubDate>${PUBDATE}</pubDate>" >> new_item.xml
        echo "                <enclosure url=\"${DOWNLOAD_URL}\"" >> new_item.xml
        echo "                           sparkle:version=\"${APP_VERSION}\"" >> new_item.xml
        echo "                           sparkle:shortVersionString=\"${APP_VERSION}\"" >> new_item.xml
        echo "                           sparkle:edSignature=\"${SIGNATURE}\"" >> new_item.xml
        echo "                           length=\"${ZIP_SIZE}\"" >> new_item.xml
        echo "                           type=\"application/octet-stream\"" >> new_item.xml
        echo "                           sparkle:os=\"macos\" />" >> new_item.xml
        echo "                <sparkle:minimumSystemVersion>${MIN_OS}</sparkle:minimumSystemVersion>" >> new_item.xml
        echo "            </item>" >> new_item.xml
        
        # Merge with existing appcast
        if [ -f "appcast.xml" ]; then
          awk '/<channel>/{print; print "        <!-- Auto-generated by GitHub Actions -->"; while(getline < "new_item.xml") print; next}1' appcast.xml > appcast_new.xml
          mv appcast_new.xml appcast.xml
        else
          # Create new appcast using echo
          echo '<?xml version="1.0" encoding="utf-8"?>' > appcast.xml
          echo '<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">' >> appcast.xml
          echo '    <channel>' >> appcast.xml
          echo '        <title>GhostKey Updates</title>' >> appcast.xml
          echo '        <link>https://github.com/rdpr/GhostKey</link>' >> appcast.xml
          echo '        <description>Most recent updates to GhostKey</description>' >> appcast.xml
          echo '        <language>en</language>' >> appcast.xml
          echo '        <!-- Auto-generated by GitHub Actions -->' >> appcast.xml
          cat new_item.xml >> appcast.xml
          echo '    </channel>' >> appcast.xml
          echo '</rss>' >> appcast.xml
        fi
        
        rm -f new_item.xml "$KEY_FILE" /tmp/signature_output.txt
        
        echo "âœ… Appcast updated"
        echo "ðŸ“‹ New entry:"
        sed -n '/<item>/,/<\/item>/p' appcast.xml | head -15
        
        # Verify the ZIP can be extracted
        echo "ðŸ” Verifying ZIP integrity..."
        unzip -t "$ZIP_FILE" || echo "âš ï¸ ZIP verification failed"
        
        # Show ZIP contents
        echo "ðŸ“‹ ZIP contents:"
        unzip -l "$ZIP_FILE" | head -20
    
    - name: Commit appcast changes
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ’¾ Committing appcast changes..."
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # Restore Info.plist to avoid committing version changes
        git checkout GhostKey/Info.plist
        
        git add appcast.xml
        
        if git diff --staged --quiet; then
          echo "âš ï¸  No changes to commit"
        else
          git commit -m "chore: update appcast for v${{ steps.version.outputs.version }}"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
          echo "âœ… Appcast committed and pushed"
        fi
    
    - name: Generate checksums
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ” Generating checksums..."
        shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.zip" > "GhostKey-${{ steps.version.outputs.version }}.zip.sha256"
        shasum -a 256 "GhostKey-${{ steps.version.outputs.version }}.dmg" > "GhostKey-${{ steps.version.outputs.version }}.dmg.sha256"
        
        echo "ðŸ“‹ Checksums:"
        cat "GhostKey-${{ steps.version.outputs.version }}.zip.sha256"
        cat "GhostKey-${{ steps.version.outputs.version }}.dmg.sha256"
    
    - name: Create release notes
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ“ Generating release notes..."
        
        cat > release_notes.md << 'EOF'
        ## GhostKey v${{ steps.version.outputs.version }}
        
        ### ðŸ“¦ Installation
        
        Choose one of the following:
        
        1. **DMG (Recommended)**: Download `GhostKey-${{ steps.version.outputs.version }}.dmg`, open it, and drag GhostKey to your Applications folder
        2. **ZIP**: Download `GhostKey-${{ steps.version.outputs.version }}.zip`, extract it, and move GhostKey.app to your Applications folder
        
        ### ðŸ”’ Important: Opening the App
        
        This build is **not code-signed or notarized**. macOS Gatekeeper will block it by default.
        
        **Required step to open the app**:
        
        Open Terminal and run this command:
        ```bash
        xattr -d com.apple.quarantine /Applications/GhostKey.app
        ```
        
        Then double-click GhostKey.app to open it normally.
        
        > **Note**: This removes the quarantine flag that macOS adds to downloaded apps. You only need to do this once.
        
        ### âš ï¸ Known Limitation: Notifications
        
        **System notifications will NOT work** in this unsigned build. macOS requires apps to be code-signed to register for notifications.
        
        **If you need notifications**, you must build from source:
        1. Clone the repository
        2. Open `GhostKey.xcodeproj` in Xcode
        3. Build and run (âŒ˜R)
        
        Local builds are automatically signed by Xcode and have full notification support.
        
        See [DEVELOPMENT.md](https://github.com/rdpr/ghostkey/blob/main/DEVELOPMENT.md#notification-issues-unsigned-apps) for details.
        
        ### âœ… Checksums
        
        Verify your download:
        
        ```
        $(cat GhostKey-${{ steps.version.outputs.version }}.zip.sha256)
        $(cat GhostKey-${{ steps.version.outputs.version }}.dmg.sha256)
        ```
        
        ### ðŸ“‹ What's New
        
        See [CHANGELOG.md](https://github.com/rdpr/ghostkey/blob/main/CHANGELOG.md) for detailed changes.
        
        ---
        
        **Requirements**: macOS 12.0 (Monterey) or later
        
        **Permissions**: Accessibility access required for typing codes (you'll be prompted on first use)
        EOF
        
        echo "âœ… Release notes generated"
    
    - name: Create Git tag
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "ðŸ·ï¸  Creating tag v${{ steps.version.outputs.version }}..."
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release v${{ steps.version.outputs.version }}"
        
        # Push tag using HTTPS with token
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "v${{ steps.version.outputs.version }}"
        
        echo "âœ… Tag created and pushed"
    
    - name: Create GitHub Release
      if: steps.check_tag.outputs.exists == 'false'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.version }}
        name: v${{ steps.version.outputs.version }}
        body_path: release_notes.md
        draft: false
        prerelease: false
        files: |
          GhostKey-${{ steps.version.outputs.version }}.zip
          GhostKey-${{ steps.version.outputs.version }}.zip.sha256
          GhostKey-${{ steps.version.outputs.version }}.dmg
          GhostKey-${{ steps.version.outputs.version }}.dmg.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Release summary
      if: steps.check_tag.outputs.exists == 'false'
      run: |
        echo "## ðŸŽ‰ Release Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Version**: v${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“¦ Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- \`GhostKey-${{ steps.version.outputs.version }}.dmg\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`GhostKey-${{ steps.version.outputs.version }}.zip\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Links" >> $GITHUB_STEP_SUMMARY
        echo "- [Release Page](https://github.com/rdpr/ghostkey/releases/tag/v${{ steps.version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
        echo "- [All Releases](https://github.com/rdpr/ghostkey/releases)" >> $GITHUB_STEP_SUMMARY

